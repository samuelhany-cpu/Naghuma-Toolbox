#include "MainWindow.h"
#include "ImageCanvas.h"
#include "HistogramWidget.h"
#include "RightSidebarWidget.h"
#include "ImageProcessor.h"
#include "TransformDialog.h"
#include "AdjustmentDialog.h"
#include "BrushTool.h"
#include "BrushDialog.h"
#include "filters/ImageFilters.h"
#include "ImageMetrics.h"
#include <QApplication>
#include <QScreen>
#include <QVBoxLayout>
#include <QTextEdit>
#include <QHBoxLayout>
#include <algorithm>

namespace Theme {
    constexpr const char* BG_PRIMARY = "#1a0a1f";
    constexpr const char* BG_SECONDARY = "#1f1535";
    constexpr const char* FG_PRIMARY = "#f3e8ff";
    constexpr const char* FG_SECONDARY = "#c4b5fd";
    constexpr const char* ACCENT_PRIMARY = "#e879f9";
    constexpr const char* ACCENT_SECONDARY = "#c026d3";
    constexpr const char* SUCCESS_COLOR = "#98d8e8";
    constexpr const char* INFO_COLOR = "#c4b5fd";
    constexpr const char* WARNING_COLOR = "#fb7185";
    constexpr const char* ERROR_COLOR = "#f87171";
}

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), imageLoaded(false), recentlyProcessed(false), drawingMode(false) {
    
    setWindowTitle("Naghuma Toolbox - Image Processing Suite");
    setMinimumSize(1600, 900);
    
    // Initialize brush tool
    brushTool = new BrushTool(this);
    
    QString styleSheet = R"(
        QMainWindow {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                                       stop:0 #1a0a1f, stop:0.3 #251e35, 
                                       stop:0.7 #1f1535, stop:1 #1a0a1f);
        }
        QWidget {
            background-color: #1f1535;
            color: #f3e8ff;
            font-family: 'Segoe UI', -apple-system, sans-serif;
            font-size: 10pt;
        }
        QPushButton {
            background-color: rgba(45, 37, 71, 0.8);
            color: #c4b5fd;
            border: 1px solid rgba(61, 50, 80, 0.6);
            border-radius: 10px;
            padding: 12px 24px;
            font-weight: 500;
        }
        QPushButton:hover {
            background-color: rgba(91, 75, 115, 0.6);
            color: #e879f9;
            border: 1px solid rgba(232, 121, 249, 0.5);
        }
        QPushButton:pressed {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                                       stop:0 #e879f9, stop:1 #c026d3);
            color: #ffffff;
            border: none;
        }
        QPushButton.accent {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                                       stop:0 #e879f9, stop:1 #c026d3);
            color: #ffffff;
            font-weight: 600;
            border: none;
            padding: 12px 28px;
        }
        QPushButton.accent:hover {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                                       stop:0 #f0abfc, stop:1 #e879f9);
        }
        QLineEdit, QSpinBox, QDoubleSpinBox {
            background-color: rgba(45, 37, 71, 0.5);
            color: #f3e8ff;
            border: 2px solid rgba(91, 75, 115, 0.5);
            border-radius: 8px;
            padding: 10px 14px;
        }
        QLineEdit:focus, QSpinBox:focus, QDoubleSpinBox:focus {
            border: 2px solid #e879f9;
            background-color: rgba(232, 121, 249, 0.08);
        }
        QSlider::groove:horizontal {
            background: rgba(45, 37, 71, 0.6);
            height: 10px;
            border-radius: 5px;
        }
        QSlider::handle:horizontal {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                                       stop:0 #e879f9, stop:1 #c026d3);
            width: 22px;
            height: 22px;
            margin: -6px 0;
            border-radius: 11px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        QSlider::handle:horizontal:hover {
            background: #f0abfc;
        }
        QProgressBar {
            background-color: rgba(45, 37, 71, 0.6);
            border: none;
            border-radius: 8px;
            height: 14px;
            text-align: center;
            color: #ffffff;
            font-weight: 500;
        }
        QProgressBar::chunk {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                                       stop:0 #e879f9, stop:1 #c026d3);
            border-radius: 8px;
        }
        QLabel {
            background-color: transparent;
            color: #c4b5fd;
        }
        QGroupBox {
            border: 2px solid rgba(232, 121, 249, 0.35);
            border-radius: 14px;
            margin-top: 22px;
            padding: 24px 20px 20px 20px;
            font-weight: 600;
            color: #e879f9;
            background-color: rgba(45, 37, 71, 0.25);
        }
        QGroupBox::title {
            subcontrol-origin: margin;
            subcontrol-position: top left;
            padding: 0 16px;
            background-color: #1f1535;
            font-size: 11pt;
        }
        QStatusBar {
            background: rgba(26, 10, 31, 0.95);
            color: #f3e8ff;
            border-top: 2px solid rgba(232, 121, 249, 0.25);
            padding: 6px;
        }
        QMenuBar {
            background: rgba(31, 21, 53, 0.95);
            color: #f3e8ff;
            spacing: 6px;
            padding: 10px 8px;
            border-bottom: 2px solid rgba(232, 121, 249, 0.25);
        }
        QMenuBar::item {
            padding: 10px 20px;
            background: transparent;
            border-radius: 8px;
        }
        QMenuBar::item:selected {
            background-color: rgba(232, 121, 249, 0.15);
            color: #e879f9;
        }
        QMenu {
            background-color: rgba(37, 30, 53, 0.98);
            border: 2px solid rgba(91, 75, 115, 0.5);
            border-radius: 12px;
            padding: 10px;
        }
        QMenu::item {
            padding: 12px 40px;
            color: #f3e8ff;
            border-radius: 8px;
        }
        QMenu::item:selected {
            background-color: rgba(232, 121, 249, 0.2);
            color: #e879f9;
        }
        QToolBar {
            background: rgba(26, 10, 31, 0.95);
            border-bottom: 2px solid rgba(232, 121, 249, 0.25);
            spacing: 12px;
            padding: 14px;
        }
        QTextEdit {
            background-color: rgba(45, 37, 71, 0.5);
            color: #f3e8ff;
            border: 2px solid rgba(91, 75, 115, 0.5);
            border-radius: 10px;
            padding: 14px;
        }
        QMessageBox {
            background-color: #1f1535;
        }
        QDialog {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                                       stop:0 #1a0a1f, stop:1 #251e35);
        }
    )";
    
    QApplication::setStyle("Fusion");
    setStyleSheet(styleSheet);
    
    setupUI();
}

MainWindow::~MainWindow() {
}

void MainWindow::setupUI() {
    createMenuBar();
    createToolBar();
    createCentralWidget();
    
    // Create and add right sidebar
    rightSidebar = new RightSidebarWidget(this);
    connect(rightSidebar, &RightSidebarWidget::layerRemoveRequested,
            this, &MainWindow::onLayerRemoveRequested);
    connect(rightSidebar, &RightSidebarWidget::layersRemoveRequested,
            this, &MainWindow::onLayersRemoveRequested);
    
    QWidget *central = centralWidget();
    QHBoxLayout *mainLayout = qobject_cast<QHBoxLayout*>(central->layout());
    if (mainLayout) {
        mainLayout->addWidget(rightSidebar);
    }
    
    createStatusBar();
    
    // Center window on screen
    QScreen *screen = QApplication::primaryScreen();
    QRect screenGeometry = screen->geometry();
    int x = (screenGeometry.width() - width()) / 2;
    int y = (screenGeometry.height() - height()) / 2;
    move(x, y);
}

void MainWindow::createMenuBar() {
    QMenuBar *menuBar = new QMenuBar(this);
    setMenuBar(menuBar);
    
    // File Menu
    QMenu *fileMenu = menuBar->addMenu("File");
    
    QAction *loadAction = fileMenu->addAction("Load Image");
    connect(loadAction, &QAction::triggered, this, &MainWindow::loadImage);
    
    QAction *saveAction = fileMenu->addAction("Save Image");
    connect(saveAction, &QAction::triggered, this, &MainWindow::saveImage);
    
    fileMenu->addSeparator();
    
    QAction *resetAction = fileMenu->addAction("Reset");
    connect(resetAction, &QAction::triggered, this, &MainWindow::resetImage);
    
    fileMenu->addSeparator();
    
    QAction *exitAction = fileMenu->addAction("Exit");
    connect(exitAction, &QAction::triggered, this, &QMainWindow::close);
    
    // Info Menu
    QMenu *infoMenu = menuBar->addMenu("Information");
    
    QAction *imageInfoAction = infoMenu->addAction("Image Info");
    connect(imageInfoAction, &QAction::triggered, this, &MainWindow::showImageInfo);
    
    QAction *pixelInfoAction = infoMenu->addAction("Pixel Info");
    connect(pixelInfoAction, &QAction::triggered, this, &MainWindow::showPixelInfo);
    
    QAction *statsAction = infoMenu->addAction("Statistics");
    connect(statsAction, &QAction::triggered, this, &MainWindow::showImageStats);
    
    infoMenu->addSeparator();
    
    QAction *metricsAction = infoMenu->addAction("Image Metrics (RMSE/SNR/PSNR)");
    connect(metricsAction, &QAction::triggered, this, &MainWindow::showImageMetrics);
    
    // Transform Menu
    QMenu *transformMenu = menuBar->addMenu("Transform");
    
    QAction *translateAction = transformMenu->addAction("Translation");
    connect(translateAction, &QAction::triggered, this, &MainWindow::applyTranslation);
    
    QAction *rotateAction = transformMenu->addAction("Rotation");
    connect(rotateAction, &QAction::triggered, this, &MainWindow::applyRotation);
    
    QAction *skewAction = transformMenu->addAction("Skew");
    connect(skewAction, &QAction::triggered, this, &MainWindow::applySkew);
    
    QAction *zoomAction = transformMenu->addAction("Zoom");
    connect(zoomAction, &QAction::triggered, this, &MainWindow::applyZoom);
    
    transformMenu->addSeparator();
    
    QAction *flipXAction = transformMenu->addAction("Flip Horizontal");
    connect(flipXAction, &QAction::triggered, this, &MainWindow::applyFlipX);
    
    QAction *flipYAction = transformMenu->addAction("Flip Vertical");
    connect(flipYAction, &QAction::triggered, this, &MainWindow::applyFlipY);
    
    QAction *flipXYAction = transformMenu->addAction("Flip Both");
    connect(flipXYAction, &QAction::triggered, this, &MainWindow::applyFlipXY);
    
    // Histogram Menu
    QMenu *histMenu = menuBar->addMenu("Histogram");
    
    QAction *showHistAction = histMenu->addAction("Show Histogram");
    connect(showHistAction, &QAction::triggered, this, &MainWindow::showHistogram);
    
    QAction *equalizeAction = histMenu->addAction("Equalization");
    connect(equalizeAction, &QAction::triggered, this, &MainWindow::applyHistogramEqualization);
    
    QAction *otsuAction = histMenu->addAction("Otsu Thresholding");
    connect(otsuAction, &QAction::triggered, this, &MainWindow::applyOtsuThresholding);
    
    // Process Menu
    QMenu *processMenu = menuBar->addMenu("Process");
    
    QAction *brightnessContrastAction = processMenu->addAction("Brightness/Contrast");
    connect(brightnessContrastAction, &QAction::triggered, this, &MainWindow::applyBrightnessContrast);
    
    processMenu->addSeparator();
    
    QAction *grayscaleAction = processMenu->addAction("Grayscale");
    connect(grayscaleAction, &QAction::triggered, this, &MainWindow::convertToGrayscale);
    
    QAction *binaryAction = processMenu->addAction("Binary Threshold");
    connect(binaryAction, &QAction::triggered, this, &MainWindow::applyBinaryThreshold);
    
    QAction *blurAction = processMenu->addAction("Gaussian Blur");
    connect(blurAction, &QAction::triggered, this, &MainWindow::applyGaussianBlur);
    
    QAction *edgeAction = processMenu->addAction("Edge Detection");
    connect(edgeAction, &QAction::triggered, this, &MainWindow::applyEdgeDetection);
    
    QAction *invertAction = processMenu->addAction("Invert Colors");
    connect(invertAction, &QAction::triggered, this, &MainWindow::invertColors);
    
    // Filters Menu - Professional Library Integration
    QMenu *filtersMenu = menuBar->addMenu("Filters");
    
    // Add filters from the lab code
    QAction *laplacianAction = filtersMenu->addAction("Laplacian Filter");
    connect(laplacianAction, &QAction::triggered, this, &MainWindow::applyLaplacianFilter);
    
    QAction *sobelAction = filtersMenu->addAction("Sobel Filter");
    connect(sobelAction, &QAction::triggered, this, &MainWindow::applySobelCombinedFilter);
    
    QAction *traditionalAction = filtersMenu->addAction("Traditional Filter");
    connect(traditionalAction, &QAction::triggered, this, &MainWindow::applyTraditionalFilter);
    
    QAction *pyramidalAction = filtersMenu->addAction("Pyramidal Filter");
    connect(pyramidalAction, &QAction::triggered, this, &MainWindow::applyPyramidalFilter);
    
    QAction *circularAction = filtersMenu->addAction("Circular Filter");
    connect(circularAction, &QAction::triggered, this, &MainWindow::applyCircularFilter);
    
    QAction *coneAction = filtersMenu->addAction("Cone Filter");
    connect(coneAction, &QAction::triggered, this, &MainWindow::applyConeFilter);
    
    // Morphology Menu
    QMenu *morphMenu = menuBar->addMenu("Morphology");
    
    QAction *erosionAction = morphMenu->addAction("Erosion");
    connect(erosionAction, &QAction::triggered, this, &MainWindow::applyErosion);
    
    QAction *dilationAction = morphMenu->addAction("Dilation");
    connect(dilationAction, &QAction::triggered, this, &MainWindow::applyDilation);
    
    morphMenu->addSeparator();
    
    QAction *openingAction = morphMenu->addAction("Opening");
    connect(openingAction, &QAction::triggered, this, &MainWindow::applyOpening);
    
    QAction *closingAction = morphMenu->addAction("Closing");
    connect(closingAction, &QAction::triggered, this, &MainWindow::applyClosing);
    
    morphMenu->addSeparator();
    
    QAction *gradientAction = morphMenu->addAction("Morphological Gradient");
    connect(gradientAction, &QAction::triggered, this, &MainWindow::applyMorphGradient);
    
    // FFT Menu
    QMenu *fftMenu = menuBar->addMenu("FFT");
    
    QAction *fftSpectrumAction = fftMenu->addAction("Show FFT Spectrum");
    connect(fftSpectrumAction, &QAction::triggered, this, &MainWindow::showFFTSpectrum);
    
    fftMenu->addSeparator();
    
    QAction *lowPassAction = fftMenu->addAction("Low-Pass Filter");
    connect(lowPassAction, &QAction::triggered, this, &MainWindow::applyLowPassFilter);
    
    QAction *highPassAction = fftMenu->addAction("High-Pass Filter");
    connect(highPassAction, &QAction::triggered, this, &MainWindow::applyHighPassFilter);
    
    // Tools Menu
    QMenu *toolsMenu = menuBar->addMenu("Tools");
    
    QAction *brushAction = toolsMenu->addAction("Brush Settings");
    connect(brushAction, &QAction::triggered, this, &MainWindow::showBrushSettings);
    
    toolsMenu->addSeparator();
    
    QAction *drawModeAction = toolsMenu->addAction("Toggle Drawing Mode");
    drawModeAction->setCheckable(true);
    connect(drawModeAction, &QAction::triggered, this, &MainWindow::toggleDrawingMode);
    
    QAction *applyBrushAction = toolsMenu->addAction("Apply Brush Effect (Auto)");
    connect(applyBrushAction, &QAction::triggered, this, &MainWindow::applyBrushEffect);
}

void MainWindow::createToolBar() {
    QToolBar *toolbar = new QToolBar(this);
    toolbar->setMovable(false);
    toolbar->setIconSize(QSize(24, 24));
    addToolBar(Qt::TopToolBarArea, toolbar);
    
    // Load button
    QPushButton *loadBtn = new QPushButton("Load Image", this);
    loadBtn->setProperty("class", "accent");
    loadBtn->setMinimumWidth(140);
    connect(loadBtn, &QPushButton::clicked, this, &MainWindow::loadImage);
    toolbar->addWidget(loadBtn);
    
    toolbar->addSeparator();
    
    // Save button
    QPushButton *saveBtn = new QPushButton("Save", this);
    saveBtn->setMinimumWidth(100);
    connect(saveBtn, &QPushButton::clicked, this, &MainWindow::saveImage);
    toolbar->addWidget(saveBtn);
    
    // Reset button
    QPushButton *resetBtn = new QPushButton("Reset", this);
    resetBtn->setMinimumWidth(100);
    connect(resetBtn, &QPushButton::clicked, this, &MainWindow::resetImage);
    toolbar->addWidget(resetBtn);
    
    // Use Processed button - apply processed image as current
    QPushButton *useProcessedBtn = new QPushButton("Use Processed", this);
    useProcessedBtn->setMinimumWidth(120);
    useProcessedBtn->setToolTip("Use the processed image for next operations");
    connect(useProcessedBtn, &QPushButton::clicked, this, &MainWindow::useProcessedImage);
    toolbar->addWidget(useProcessedBtn);
    
    toolbar->addSeparator();
    
    // Quick process buttons
    QPushButton *grayBtn = new QPushButton("Grayscale", this);
    connect(grayBtn, &QPushButton::clicked, this, &MainWindow::convertToGrayscale);
    toolbar->addWidget(grayBtn);
    
    QPushButton *blurBtn = new QPushButton("Blur", this);
    connect(blurBtn, &QPushButton::clicked, this, &MainWindow::applyGaussianBlur);
    toolbar->addWidget(blurBtn);
    
    QPushButton *edgeBtn = new QPushButton("Edges", this);
    connect(edgeBtn, &QPushButton::clicked, this, &MainWindow::applyEdgeDetection);
    toolbar->addWidget(edgeBtn);
    
    toolbar->addSeparator();
    
    // Drawing mode toggle
    QPushButton *drawModeBtn = new QPushButton("Drawing Mode: OFF", this);
    drawModeBtn->setObjectName("drawModeButton");
    drawModeBtn->setCheckable(true);
    drawModeBtn->setMinimumWidth(140);
    connect(drawModeBtn, &QPushButton::clicked, this, &MainWindow::toggleDrawingMode);
    toolbar->addWidget(drawModeBtn);
}

void MainWindow::createCentralWidget() {
    QWidget *centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);
    
    QHBoxLayout *mainLayout = new QHBoxLayout(centralWidget);
    mainLayout->setSpacing(0);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    
    // Left and center area for images
    QWidget *imagesArea = new QWidget();
    QHBoxLayout *imagesLayout = new QHBoxLayout(imagesArea);
    imagesLayout->setSpacing(20);
    imagesLayout->setContentsMargins(20, 20, 20, 20);
    
    // Original image section with glow border
    QVBoxLayout *originalLayout = new QVBoxLayout();
    
    QLabel *originalTitle = new QLabel("Original");
    originalTitle->setStyleSheet("font-size: 14pt; font-weight: 600; color: #e879f9; padding: 8px; letter-spacing: 0.5px;");
    originalLayout->addWidget(originalTitle);
    
    // Container for canvas with border glow
    QWidget *originalContainer = new QWidget();
    originalContainer->setStyleSheet(
        "background-color: rgba(45, 37, 71, 0.2); "
        "border: 2px solid rgba(232, 121, 249, 0.35); "
        "border-radius: 16px; "
    );
    QVBoxLayout *originalContainerLayout = new QVBoxLayout(originalContainer);
    originalContainerLayout->setContentsMargins(0, 0, 0, 0);
    
    originalCanvas = new ImageCanvas(originalContainer, "#e879f9");
    originalContainerLayout->addWidget(originalCanvas);
    
    originalLayout->addWidget(originalContainer, 1);
    
    originalInfoLabel = new QLabel("No image loaded");
    originalInfoLabel->setStyleSheet("color: #c4b5fd; padding: 8px; font-size: 9pt; font-weight: 500;");
    originalInfoLabel->setAlignment(Qt::AlignCenter);
    originalLayout->addWidget(originalInfoLabel);
    
    imagesLayout->addLayout(originalLayout, 1);
    
    // Processed image section with glow border
    QVBoxLayout *processedLayout = new QVBoxLayout();
    
    QLabel *processedTitle = new QLabel("Processed");
    processedTitle->setStyleSheet("font-size: 14pt; font-weight: 600; color: #c026d3; padding: 8px; letter-spacing: 0.5px;");
    processedLayout->addWidget(processedTitle);
    
    // Container for canvas with border glow
    QWidget *processedContainer = new QWidget();
    processedContainer->setStyleSheet(
        "background-color: rgba(45, 37, 71, 0.2); "
        "border: 2px solid rgba(192, 38, 211, 0.4); "
        "border-radius: 16px; "
    );
    QVBoxLayout *processedContainerLayout = new QVBoxLayout(processedContainer);
    processedContainerLayout->setContentsMargins(0, 0, 0, 0);
    
    processedCanvas = new ImageCanvas(processedContainer, "#c026d3");
    processedContainerLayout->addWidget(processedCanvas);
    
    // Connect mouse events for drawing
    connect(processedCanvas, &ImageCanvas::mousePressed, this, &MainWindow::onCanvasMousePress);
    connect(processedCanvas, &ImageCanvas::mouseMoved, this, &MainWindow::onCanvasMouseMove);
    connect(processedCanvas, &ImageCanvas::mouseReleased, this, &MainWindow::onCanvasMouseRelease);
    
    processedLayout->addWidget(processedContainer, 1);
    
    // Metrics label (below both images)
    metricsLabel = new QLabel("");
    metricsLabel->setStyleSheet(
        "background-color: rgba(45, 37, 71, 0.7); "
        "color: #98d8e8; "
        "padding: 12px; "
        "font-size: 10pt; "
        "font-weight: 600; "
        "border: 1px solid rgba(232, 121, 249, 0.3); "
        "border-radius: 8px; "
        "font-family: 'Consolas', monospace;"
    );
    metricsLabel->setAlignment(Qt::AlignCenter);
    metricsLabel->setVisible(false);
    processedLayout->addWidget(metricsLabel);
    
    imagesLayout->addLayout(processedLayout, 1);
    
    mainLayout->addWidget(imagesArea, 1);
}

void MainWindow::createStatusBar() {
    QStatusBar *status = statusBar();
    
    statusLabel = new QLabel("Welcome to Naghuma Toolbox! Load an image to get started...");
    statusLabel->setStyleSheet("color: #e879f9; padding: 5px; font-weight: 500;");
    status->addWidget(statusLabel, 1);
    
    progressBar = new QProgressBar(this);
    progressBar->setMaximumWidth(200);
    progressBar->setMaximumHeight(20);
    progressBar->setVisible(false);
    status->addPermanentWidget(progressBar);
}

// ===== Helper Functions =====

void MainWindow::updateDisplay() {
    if (imageLoaded && !originalImage.empty()) {
        originalCanvas->setImage(originalImage);
        QString info = QString("Size: %1 x %2 | Channels: %3")
                      .arg(originalImage.cols)
                      .arg(originalImage.rows)
                      .arg(originalImage.channels());
        originalInfoLabel->setText(info);
    }
    
    if (recentlyProcessed && !processedImage.empty()) {
        processedCanvas->setImage(processedImage);
        QString info = QString("Size: %1 x %2 | Channels: %3")
                      .arg(processedImage.cols)
                      .arg(processedImage.rows)
                      .arg(processedImage.channels());
        processedInfoLabel->setText(info);
        
        // Update metrics display
        updateMetricsDisplay();
    } else {
        metricsLabel->setVisible(false);
    }
}

void MainWindow::updateMetricsDisplay() {
    if (!imageLoaded || !recentlyProcessed || processedImage.empty()) {
        metricsLabel->setVisible(false);
        return;
    }
    
    auto result = ImageMetrics::calculateMetrics(originalImage, processedImage);
    
    if (!result.isValid) {
        metricsLabel->setVisible(false);
        return;
    }
    
    QString metricsText = QString("RMSE: %1 | SNR: %2 dB | PSNR: %3 dB")
        .arg(result.rmse, 0, 'f', 2)
        .arg(result.snr, 0, 'f', 2)
        .arg(std::isinf(result.psnr) ? QString("?") : QString::number(result.psnr, 'f', 2));
    
    metricsLabel->setText(metricsText);
    metricsLabel->setVisible(true);
}

void MainWindow::updateStatus(const QString& message, const QString& type, int progress) {
    QString prefix;
    QString color;
    
    if (type == "success") {
        prefix = "[OK] ";
        color = Theme::SUCCESS_COLOR;
    } else if (type == "error") {
        prefix = "[ERROR] ";
        color = Theme::ERROR_COLOR;
    } else if (type == "warning") {
        prefix = "[WARNING] ";
        color = Theme::WARNING_COLOR;
    } else {
        prefix = "[INFO] ";
        color = Theme::INFO_COLOR;
    }
    
    statusLabel->setText(prefix + message);
    statusLabel->setStyleSheet(QString("color: %1; padding: 5px; font-weight: 500;").arg(color));
    
    if (progress >= 0) {
        progressBar->setValue(progress);
        progressBar->setVisible(true);
    } else {
        progressBar->setVisible(false);
    }
}

void MainWindow::finalizeProcessing(const QString& layerName, const QString& layerType) {
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        
        // Create operation function that captures the current processing
        auto operation = [this, processedImg = processedImage.clone()](const cv::Mat& input) -> cv::Mat {
            // Store what operation was performed by comparing processed vs current
            // For now, return the stored result
            return processedImg;
        };
        
        rightSidebar->addLayer(layerName, layerType, processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
}

void MainWindow::onLayerRemoveRequested(int layerIndex) {
    QMessageBox::StandardButton reply = QMessageBox::question(
        this,
        "Remove Layer",
        "Remove this processing layer-\n\nImage will be rebuilt from remaining operations.",
        QMessageBox::Yes | QMessageBox::No
    );
    
    if (reply == QMessageBox::Yes) {
        // Remove the layer from the sidebar
        rightSidebar->removeLayer(layerIndex);
        
        // Rebuild image from remaining layers
        int remainingLayers = rightSidebar->getLayerCount();
        
        if (remainingLayers == 0) {
            // No layers left - show original
            currentImage = originalImage.clone();
            processedImage = cv::Mat();
            recentlyProcessed = false;
            processedCanvas->clear();
        } else {
            // Rebuild from all remaining layers
            cv::Mat rebuiltImage = rightSidebar->rebuildImage(originalImage);
            
            if (!rebuiltImage.empty()) {
                currentImage = rebuiltImage.clone();
                processedImage = rebuiltImage.clone();
                recentlyProcessed = true;
            } else {
                // Fallback to previous layer's image
                if (layerIndex > 0) {
                    processedImage = rightSidebar->getLayerImage(layerIndex - 1);
                } else {
                    processedImage = rightSidebar->getLayerImage(0);
                }
                currentImage = processedImage.clone();
                recentlyProcessed = true;
            }
        }
        
        // Update display
        updateDisplay();
        rightSidebar->updateHistogram(currentImage);
        
        updateStatus(QString("Layer removed. %1 layers remaining.")
            .arg(rightSidebar->getLayerCount()), "success");
    }
}

void MainWindow::onLayersRemoveRequested(const QList<int>& layerIndices) {
    if (layerIndices.isEmpty()) return;
    
    QString message = layerIndices.size() == 1 
        ? "Remove 1 layer-"
        : QString("Remove %1 layers?").arg(layerIndices.size());
    message += "\n\nImage will be rebuilt from remaining operations.";
    
    QMessageBox::StandardButton reply = QMessageBox::question(
        this,
        "Remove Layers",
        message,
        QMessageBox::Yes | QMessageBox::No
    );
    
    if (reply == QMessageBox::Yes) {
        // Sort indices in descending order to remove from end to start
        QList<int> sortedIndices = layerIndices;
        std::sort(sortedIndices.begin(), sortedIndices.end(), std::greater<int>());
        
        // Remove all selected layers
        for (int index : sortedIndices) {
            rightSidebar->removeLayer(index);
        }
        
        // Rebuild image from remaining layers
        int remainingLayers = rightSidebar->getLayerCount();
        
        if (remainingLayers == 0) {
            // No layers left - show original
            currentImage = originalImage.clone();
            processedImage = cv::Mat();
            recentlyProcessed = false;
            processedCanvas->clear();
        } else {
            // Rebuild from all remaining layers
            cv::Mat rebuiltImage = rightSidebar->rebuildImage(originalImage);
            
            if (!rebuiltImage.empty()) {
                currentImage = rebuiltImage.clone();
                processedImage = rebuiltImage.clone();
                recentlyProcessed = true;
            } else {
                // Fallback to last layer's image
                processedImage = rightSidebar->getLayerImage(remainingLayers - 1);
                currentImage = processedImage.clone();
                recentlyProcessed = true;
            }
        }
        
        // Update display
        updateDisplay();
        rightSidebar->updateHistogram(currentImage);
        
        updateStatus(QString("Removed %1 layers. %2 layers remaining.")
            .arg(layerIndices.size())
            .arg(rightSidebar->getLayerCount()), "success");
    }
}

// ===== File Operations =====

void MainWindow::loadImage() {
    QString fileName = QFileDialog::getOpenFileName(this,
        "Select Image File",
        "",
        "Images (*.png *.jpg *.jpeg *.bmp *.tiff *.tif)");
    
    if (fileName.isEmpty()) return;
    
    updateStatus("Loading image...", "info", 50);
    
    originalImage = cv::imread(fileName.toStdString());
    
    if (originalImage.empty()) {
        QMessageBox::critical(this, "Error", "Failed to load image!");
        updateStatus("Failed to load image", "error");
        return;
    }
    
    currentImage = originalImage.clone();
    imagePath = fileName;
    imageLoaded = true;
    recentlyProcessed = false;
    processedCanvas->clear();
    
    rightSidebar->clearLayers();
    rightSidebar->updateHistogram(originalImage);
    
    updateDisplay();
    updateStatus("Image loaded successfully!", "success");
}

void MainWindow::saveImage() {
    if (!recentlyProcessed || processedImage.empty()) {
        QMessageBox::warning(this, "Warning", "No processed image to save!");
        return;
    }
    
    QString fileName = QFileDialog::getSaveFileName(this,
        "Save Processed Image",
        "",
        "PNG (*.png);;JPEG (*.jpg);;BMP (*.bmp);;TIFF (*.tif *.tiff)");
    
    if (fileName.isEmpty()) return;
    
    updateStatus("Saving image...", "info", 75);
    
    bool success = cv::imwrite(fileName.toStdString(), processedImage);
    
    if (success) {
        updateStatus("Image saved successfully!", "success");
    } else {
        QMessageBox::critical(this, "Error", "Failed to save image!");
        updateStatus("Failed to save image", "error");
    }
}

void MainWindow::resetImage() {
    if (!imageLoaded) {
        QMessageBox::warning(this, "Warning", "No image loaded!");
        return;
    }
    
    currentImage = originalImage.clone();
    processedImage = cv::Mat();
    recentlyProcessed = false;
    
    rightSidebar->clearLayers();
    rightSidebar->updateHistogram(originalImage);
    
    processedCanvas->clear();
    updateDisplay();
    updateStatus("Image reset to original", "info");
}

void MainWindow::useProcessedImage() {
    if (!recentlyProcessed || processedImage.empty()) {
        QMessageBox::warning(this, "Warning", "No processed image available!");
        return;
    }
    
    currentImage = processedImage.clone();
    originalCanvas->setImage(currentImage);
    processedCanvas->clear();
    processedImage = cv::Mat();
    recentlyProcessed = false;
    
    updateDisplay();
    updateStatus("Using processed image as current. Ready for new operations.", "success");
}

// ===== Information Functions =====

void MainWindow::showImageInfo() {
    if (!imageLoaded) {
        QMessageBox::information(this, "Info", "No image loaded!");
        return;
    }
    QString info = QString("Size: %1x%2\nChannels: %3\nType: %4")
        .arg(currentImage.cols)
        .arg(currentImage.rows)
        .arg(currentImage.channels())
        .arg(currentImage.depth() == CV_8U ? "8-bit" : "Other");
    QMessageBox::information(this, "Image Info", info);
}

void MainWindow::showPixelInfo() {
    if (!imageLoaded) {
        QMessageBox::information(this, "Info", "No image loaded!");
        return;
    }
    QMessageBox::information(this, "Pixel Info", "Click on the image canvas to see pixel values");
}

void MainWindow::showImageStats() {
    if (!imageLoaded) {
        QMessageBox::information(this, "Info", "No image loaded!");
        return;
    }
    double minVal, maxVal;
    cv::minMaxLoc(currentImage, &minVal, &maxVal);
    QString stats = QString("Min: %1\nMax: %2").arg(minVal).arg(maxVal);
    QMessageBox::information(this, "Statistics", stats);
}

// ===== Transform Operations =====

void MainWindow::applyTranslation() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    TranslationDialog dialog(currentImage, this);
    
    // Connect preview signal to update processed image
    connect(&dialog, &TranslationDialog::previewUpdated, this, [this](const cv::Mat& preview) {
        processedImage = preview.clone();
        recentlyProcessed = true;
        updateDisplay();
    });
    
    if (dialog.exec() == QDialog::Accepted && dialog.wasApplied()) {
        processedImage = dialog.getTransformedImage();
        recentlyProcessed = true;
        updateDisplay();
        finalizeProcessing(QString("Translation (%1, %2)")
            .arg(dialog.getTranslationX())
            .arg(dialog.getTranslationY()), "transform");
        updateStatus("Translation applied successfully!", "success");
    } else {
        // User cancelled - clear preview
        processedImage = cv::Mat();
        recentlyProcessed = false;
        processedCanvas->clear();
        updateDisplay();
    }
}

void MainWindow::applyRotation() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    RotationDialog dialog(currentImage, this);
    
    // Connect preview signal to update processed image
    connect(&dialog, &RotationDialog::previewUpdated, this, [this](const cv::Mat& preview) {
        processedImage = preview.clone();
        recentlyProcessed = true;
        updateDisplay();
    });
    
    if (dialog.exec() == QDialog::Accepted && dialog.wasApplied()) {
        processedImage = dialog.getTransformedImage();
        recentlyProcessed = true;
        updateDisplay();
        finalizeProcessing(QString("Rotation %1°")
            .arg(dialog.getAngle(), 0, 'f', 1), "transform");
        updateStatus("Rotation applied successfully!", "success");
    } else {
        // User cancelled - clear preview
        processedImage = cv::Mat();
        recentlyProcessed = false;
        processedCanvas->clear();
        updateDisplay();
    }
}

void MainWindow::applySkew() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    SkewDialog dialog(currentImage, this);
    
    // Connect preview signal to update processed image
    connect(&dialog, &SkewDialog::previewUpdated, this, [this](const cv::Mat& preview) {
        processedImage = preview.clone();
        recentlyProcessed = true;
        updateDisplay();
    });
    
    if (dialog.exec() == QDialog::Accepted && dialog.wasApplied()) {
        processedImage = dialog.getTransformedImage();
        recentlyProcessed = true;
        updateDisplay();
        
        // Store the actual operation with captured parameters
        double skewX = dialog.getSkewX();
        double skewY = dialog.getSkewY();
        auto operation = [skewX, skewY](const cv::Mat& input) -> cv::Mat {
            cv::Mat result;
            ImageProcessor::applySkew(input, result, skewX, skewY);
            return result;
        };
        
        if (!processedImage.empty()) {
            currentImage = processedImage.clone();
            rightSidebar->addLayer(QString("Skew (%.2f, %.2f)").arg(skewX).arg(skewY), 
                                  "transform", processedImage, operation);
            rightSidebar->updateHistogram(processedImage);
        }
        
        updateStatus("Skew applied successfully!", "success");
    } else {
        // User cancelled - clear preview
        processedImage = cv::Mat();
        recentlyProcessed = false;
        processedCanvas->clear();
        updateDisplay();
    }
}

void MainWindow::applyZoom() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ZoomDialog dialog(currentImage, this);
    
    // Connect preview signal to update processed image
    connect(&dialog, &ZoomDialog::previewUpdated, this, [this](const cv::Mat& preview) {
        processedImage = preview.clone();
        recentlyProcessed = true;
        updateDisplay();
    });
    
    if (dialog.exec() == QDialog::Accepted && dialog.wasApplied()) {
        processedImage = dialog.getTransformedImage();
        recentlyProcessed = true;
        updateDisplay();
        finalizeProcessing(QString("Zoom %1x")
            .arg(dialog.getScale(), 0, 'f', 2), "transform");
        updateStatus("Zoom applied successfully!", "success");
    } else {
        // User cancelled - clear preview
        processedImage = cv::Mat();
        recentlyProcessed = false;
        processedCanvas->clear();
        updateDisplay();
    }
}

void MainWindow::applyFlipX() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::flipHorizontal(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    finalizeProcessing("Flip Horizontal", "transform");
    updateStatus("Flipped horizontally!", "success");
}

void MainWindow::applyFlipY() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::flipVertical(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    finalizeProcessing("Flip Vertical", "transform");
    updateStatus("Flipped vertically!", "success");
}

void MainWindow::applyFlipXY() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::flipBoth(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    finalizeProcessing("Flip Both", "transform");
    updateStatus("Flipped both ways!", "success");
}

// ===== Histogram Operations =====

void MainWindow::showHistogram() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    QDialog *histDialog = new QDialog(this);
    histDialog->setWindowTitle("Image Histogram");
    histDialog->setMinimumSize(750, 550);
    
    QVBoxLayout *layout = new QVBoxLayout(histDialog);
    
    QLabel *titleLabel = new QLabel("Pixel Value Distribution");
    titleLabel->setStyleSheet("font-size: 14pt; font-weight: bold; color: #e879f9; padding: 15px;");
    layout->addWidget(titleLabel);
    
    HistogramWidget *histWidget = new HistogramWidget(histDialog);
    histWidget->setImage(currentImage);
    layout->addWidget(histWidget);
    
    QPushButton *closeBtn = new QPushButton("Close");
    closeBtn->setProperty("class", "accent");
    closeBtn->setMaximumWidth(150);
    connect(closeBtn, &QPushButton::clicked, histDialog, &QDialog::accept);
    
    QHBoxLayout *btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    btnLayout->addWidget(closeBtn);
    layout->addLayout(btnLayout);
    
    histDialog->exec();
}

void MainWindow::applyHistogramEqualization() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::equalizeHistogram(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    finalizeProcessing("Histogram Equalization", "adjustment");
    updateStatus("Histogram equalization applied!", "success");
}

void MainWindow::applyOtsuThresholding() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyOtsuThreshold(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    finalizeProcessing("Otsu Thresholding", "adjustment");
    updateStatus("Otsu thresholding applied!", "success");
}

// ===== Image Processing =====

void MainWindow::applyBrightnessContrast() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    AdjustmentDialog dialog(currentImage, this);
    
    // Connect preview signal to update processed image
    connect(&dialog, &AdjustmentDialog::previewUpdated, this, [this](const cv::Mat& preview) {
        processedImage = preview.clone();
        recentlyProcessed = true;
        updateDisplay();
    });
    
    if (dialog.exec() == QDialog::Accepted && dialog.wasApplied()) {
        processedImage = dialog.getAdjustedImage();
        recentlyProcessed = true;
        updateDisplay();
        
        // Store the actual operation with captured parameters
        int brightness = dialog.getBrightness();
        int contrast = dialog.getContrast();
        auto operation = [brightness, contrast](const cv::Mat& input) -> cv::Mat {
            cv::Mat result;
            ImageProcessor::adjustBrightnessContrast(input, result, brightness, contrast);
            return result;
        };
        
        if (!processedImage.empty()) {
            currentImage = processedImage.clone();
            rightSidebar->addLayer(QString("Brightness/Contrast (%1, %2)")
                                  .arg(brightness).arg(contrast), 
                                  "adjustment", processedImage, operation);
            rightSidebar->updateHistogram(processedImage);
        }
        
        updateStatus("Brightness/Contrast applied successfully!", "success");
    } else {
        // User cancelled - clear preview
        processedImage = cv::Mat();
        recentlyProcessed = false;
        processedCanvas->clear();
        updateDisplay();
    }
}

void MainWindow::convertToGrayscale() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::convertToGrayscale(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    // Store the actual operation
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::convertToGrayscale(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Grayscale", "adjustment", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Converted to grayscale!", "success");
}

void MainWindow::applyBinaryThreshold() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyBinaryThreshold(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyBinaryThreshold(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Binary Threshold", "adjustment", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Binary threshold applied!", "success");
}

void MainWindow::applyGaussianBlur() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyGaussianBlur(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyGaussianBlur(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Gaussian Blur", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Gaussian blur applied!", "success");
}

void MainWindow::applyEdgeDetection() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::detectEdges(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::detectEdges(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Edge Detection", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Edge detection applied!", "success");
}

void MainWindow::invertColors() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::invertColors(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::invertColors(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Invert Colors", "adjustment", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Colors inverted!", "success");
}

// ===== Filter Operations =====

void MainWindow::applyLaplacianFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageFilters::applyLaplacian(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageFilters::applyLaplacian(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Laplacian Filter", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Laplacian filter applied successfully!", "success");
}

void MainWindow::applySobelCombinedFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    cv::Mat dst_H, dst_V, dst_D;
    ImageFilters::applySobelCombined(currentImage, dst_H, dst_V, dst_D, processedImage, 3);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat dst_H, dst_V, dst_D, result;
        ImageFilters::applySobelCombined(input, dst_H, dst_V, dst_D, result, 3);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Sobel Filter (H+V+D)", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Sobel filter applied successfully!", "success");
}

void MainWindow::applyTraditionalFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageFilters::applyTraditionalFilter(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageFilters::applyTraditionalFilter(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Traditional Filter", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Traditional filter applied successfully!", "success");
}

void MainWindow::applyPyramidalFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageFilters::applyPyramidalFilter(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageFilters::applyPyramidalFilter(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Pyramidal Filter", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Pyramidal filter applied successfully!", "success");
}

void MainWindow::applyCircularFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageFilters::applyCircularFilter(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageFilters::applyCircularFilter(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Circular Filter", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Circular filter applied successfully!", "success");
}

void MainWindow::applyConeFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageFilters::applyConeFilter(currentImage, processedImage);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageFilters::applyConeFilter(input, result);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Cone Filter", "filter", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Cone filter applied successfully!", "success");
}

// ===== Morphology Operations =====

void MainWindow::applyErosion() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyErosion(currentImage, processedImage, 5);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyErosion(input, result, 5);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Erosion", "morphology", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Erosion applied successfully!", "success");
}

void MainWindow::applyDilation() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyDilation(currentImage, processedImage, 5);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyDilation(input, result, 5);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Dilation", "morphology", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Dilation applied successfully!", "success");
}

void MainWindow::applyOpening() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyOpening(currentImage, processedImage, 5);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyOpening(input, result, 5);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Opening", "morphology", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Opening applied successfully!", "success");
}

void MainWindow::applyClosing() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyClosing(currentImage, processedImage, 5);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyClosing(input, result, 5);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Closing", "morphology", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Closing applied successfully!", "success");
}

void MainWindow::applyMorphGradient() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyMorphGradient(currentImage, processedImage, 5);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyMorphGradient(input, result, 5);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Morphological Gradient", "morphology", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Morphological gradient applied successfully!", "success");
}

// ===== FFT Operations =====

void MainWindow::showFFTSpectrum() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    cv::Mat magnitude, phase;
    ImageProcessor::applyFFT(currentImage, magnitude, phase);
    
    QDialog *fftDialog = new QDialog(this);
    fftDialog->setWindowTitle("FFT Spectrum");
    fftDialog->setMinimumSize(600, 500);
    
    QVBoxLayout *layout = new QVBoxLayout(fftDialog);
    
    QLabel *titleLabel = new QLabel("Frequency Domain Representation");
    titleLabel->setStyleSheet("font-size: 14pt; font-weight: bold; color: #e879f9; padding: 15px;");
    layout->addWidget(titleLabel);
    
    // Display magnitude spectrum
    ImageCanvas *spectrumCanvas = new ImageCanvas(fftDialog, "#e879f9");
    spectrumCanvas->setMinimumSize(400, 400);
    spectrumCanvas->setImage(magnitude);
    layout->addWidget(spectrumCanvas);
    
    QLabel *infoLabel = new QLabel("Brighter regions = Higher frequency components");
    infoLabel->setStyleSheet("color: #c4b5fd; padding: 10px; font-size: 10pt;");
    infoLabel->setAlignment(Qt::AlignCenter);
    layout->addWidget(infoLabel);
    
    QPushButton *closeBtn = new QPushButton("Close");
    closeBtn->setProperty("class", "accent");
    closeBtn->setMaximumWidth(150);
    connect(closeBtn, &QPushButton::clicked, fftDialog, &QDialog::accept);
    
    QHBoxLayout *btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    btnLayout->addWidget(closeBtn);
    layout->addLayout(btnLayout);
    
    fftDialog->exec();
}

void MainWindow::applyLowPassFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyLowPassFilter(currentImage, processedImage, 30);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyLowPassFilter(input, result, 30);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("Low-Pass Filter", "fft", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("Low-pass filter applied successfully!", "success");
}

void MainWindow::applyHighPassFilter() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    ImageProcessor::applyHighPassFilter(currentImage, processedImage, 30);
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [](const cv::Mat& input) -> cv::Mat {
        cv::Mat result;
        ImageProcessor::applyHighPassFilter(input, result, 30);
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer("High-Pass Filter", "fft", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    updateStatus("High-pass filter applied successfully!", "success");
}

// ===== Brush Tool =====

void MainWindow::showBrushSettings() {
    BrushDialog dialog(brushTool, this);
    dialog.exec();
}

void MainWindow::toggleDrawingMode() {
    if (!imageLoaded) {
        QMessageBox::warning(this, "Warning", "Please load an image first!");
        return;
    }
    
    if (currentImage.empty()) {
        QMessageBox::warning(this, "Warning", "Current image is not available!");
        return;
    }
    
    drawingMode = !drawingMode;
    
    // Update button text
    QPushButton *btn = findChild<QPushButton*>("drawModeButton");
    if (btn) {
        if (drawingMode) {
            btn->setText("Drawing Mode: ON");
            btn->setProperty("class", "accent");
            btn->style()->unpolish(btn);
            btn->style()->polish(btn);
        } else {
            btn->setText("Drawing Mode: OFF");
            btn->setProperty("class", "");
            btn->style()->unpolish(btn);
            btn->style()->polish(btn);
        }
    }
    
    // Enable/disable mouse events on processed canvas
    processedCanvas->setMouseEventsEnabled(drawingMode);
    
    if (drawingMode) {
        // Start with current image as drawing canvas
        try {
            drawingCanvas = currentImage.clone();
            
            if (drawingCanvas.empty()) {
                QMessageBox::critical(this, "Error", "Failed to create drawing canvas!");
                drawingMode = false;
                processedCanvas->setMouseEventsEnabled(false);
                if (btn) btn->setText("Drawing Mode: OFF");
                return;
            }
            
            processedImage = drawingCanvas.clone();
            recentlyProcessed = true;
            updateDisplay();
            updateStatus("Drawing mode ENABLED. Click and drag on the processed image to draw!", "success");
        } catch (const std::exception& e) {
            QMessageBox::critical(this, "Error", QString("Failed to initialize drawing: %1").arg(e.what()));
            drawingMode = false;
            processedCanvas->setMouseEventsEnabled(false);
            if (btn) btn->setText("Drawing Mode: OFF");
        }
    } else {
        // Finalize drawing
        if (!drawingCanvas.empty()) {
            processedImage = drawingCanvas.clone();
            recentlyProcessed = true;
            
            auto operation = [finalImage = drawingCanvas.clone()](const cv::Mat& input) -> cv::Mat {
                return finalImage;
            };
            
            currentImage = processedImage.clone();
            rightSidebar->addLayer("Hand Drawn", "brush", processedImage, operation);
            rightSidebar->updateHistogram(processedImage);
        }
        
        // Clear drawing canvas
        drawingCanvas.release();
        
        updateDisplay();
        updateStatus("Drawing mode DISABLED. Drawing saved as layer!", "info");
    }
}

void MainWindow::onCanvasMousePress(const QPoint& pos) {
    if (!drawingMode || drawingCanvas.empty() || pos.x() < 0 || pos.y() < 0) return;
    
    // Ensure position is within image bounds
    if (pos.x() >= drawingCanvas.cols || pos.y() >= drawingCanvas.rows) return;
    
    brushTool->startDrawing(pos);
}

void MainWindow::onCanvasMouseMove(const QPoint& pos) {
    if (!drawingMode || drawingCanvas.empty() || pos.x() < 0 || pos.y() < 0) return;
    
    // Ensure position is within image bounds
    if (pos.x() >= drawingCanvas.cols || pos.y() >= drawingCanvas.rows) return;
    
    if (brushTool->isCurrentlyDrawing()) {
        brushTool->continueDrawing(pos);
        
        // Apply brush stroke to drawing canvas
        QColor color = brushTool->getBrushColor();
        int size = brushTool->getBrushSize();
        int opacity = brushTool->getBrushOpacity();
        
        // Simple circle brush
        cv::Point center(pos.x(), pos.y());
        int radius = std::max(1, size / 2);
        
        cv::Scalar cvColor(color.blue(), color.green(), color.red());
        
        // Create temporary overlay
        cv::Mat overlay = drawingCanvas.clone();
        
        try {
            cv::circle(overlay, center, radius, cvColor, -1);
            
            // Blend with opacity
            double alpha = opacity / 100.0;
            cv::addWeighted(overlay, alpha, drawingCanvas, 1.0 - alpha, 0, drawingCanvas);
            
            // Update display
            processedImage = drawingCanvas.clone();
            processedCanvas->setImage(processedImage);
        } catch (const cv::Exception& e) {
            // Silently ignore out-of-bounds errors
            return;
        }
    }
}

void MainWindow::onCanvasMouseRelease(const QPoint& pos) {
    if (!drawingMode || drawingCanvas.empty() || pos.x() < 0 || pos.y() < 0) return;
    
    brushTool->finishDrawing();
}

void MainWindow::applyBrushEffect() {
    if (!imageLoaded) {
        QMessageBox::critical(this, "Error", "Please load an image first!");
        return;
    }
    
    // Show brush settings first
    BrushDialog dialog(brushTool, this);
    if (dialog.exec() != QDialog::Accepted) {
        return;
    }
    
    QString filter = dialog.getSelectedFilter();
    int size = brushTool->getBrushSize();
    int opacity = brushTool->getBrushOpacity();
    QColor color = brushTool->getBrushColor();
    
    // Create a circular brush mask
    processedImage = currentImage.clone();
    
    // Apply brush effect in center as demonstration
    cv::Point center(processedImage.cols / 2, processedImage.rows / 2);
    int radius = size / 2;
    
    // Create region of interest
    cv::Rect roi(
        std::max(0, center.x - radius),
        std::max(0, center.y - radius),
        std::min(processedImage.cols - std::max(0, center.x - radius), radius * 2),
        std::min(processedImage.rows - std::max(0, center.y - radius), radius * 2)
    );
    
    if (roi.width > 0 && roi.height > 0) {
        cv::Mat roiImage = processedImage(roi);
        cv::Mat filteredRoi;
        
        // Apply selected filter to ROI
        if (filter == "Blur") {
            cv::GaussianBlur(roiImage, filteredRoi, cv::Size(15, 15), 0);
        } else if (filter == "Sharpen") {
            cv::Mat kernel = (cv::Mat_<float>(3, 3) <<
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0);
            cv::filter2D(roiImage, filteredRoi, -1, kernel);
        } else if (filter == "Edge Detection") {
            cv::Mat gray;
            if (roiImage.channels() == 3) {
                cv::cvtColor(roiImage, gray, cv::COLOR_BGR2GRAY);
                cv::Canny(gray, filteredRoi, 100, 200);
                cv::cvtColor(filteredRoi, filteredRoi, cv::COLOR_GRAY2BGR);
            } else {
                cv::Canny(roiImage, filteredRoi, 100, 200);
            }
        } else if (filter == "Grayscale") {
            if (roiImage.channels() == 3) {
                cv::Mat gray;
                cv::cvtColor(roiImage, gray, cv::COLOR_BGR2GRAY);
                cv::cvtColor(gray, filteredRoi, cv::COLOR_GRAY2BGR);
            } else {
                filteredRoi = roiImage.clone();
            }
        } else if (filter == "Invert") {
            filteredRoi = 255 - roiImage;
        } else {
            // Color paint mode
            filteredRoi = cv::Mat(roiImage.size(), roiImage.type(),
                cv::Scalar(color.blue(), color.green(), color.red()));
        }
        
        // Blend with opacity using circular mask
        for (int y = 0; y < roi.height; ++y) {
            for (int x = 0; x < roi.width; ++x) {
                int dx = x - radius;
                int dy = y - radius;
                float dist = std::sqrt(dx*dx + dy*dy);
                
                if (dist <= radius) {
                    float alpha = (opacity / 100.0f);
                    cv::Vec3b& orig = roiImage.at<cv::Vec3b>(y, x);
                    cv::Vec3b& filt = filteredRoi.at<cv::Vec3b>(y, x);
                    
                    orig[0] = static_cast<uchar>(orig[0] * (1 - alpha) + filt[0] * alpha);
                    orig[1] = static_cast<uchar>(orig[1] * (1 - alpha) + filt[1] * alpha);
                    orig[2] = static_cast<uchar>(orig[2] * (1 - alpha) + filt[2] * alpha);
                }
            }
        }
    }
    
    recentlyProcessed = true;
    updateDisplay();
    
    auto operation = [filter, size, opacity, color](const cv::Mat& input) -> cv::Mat {
        cv::Mat result = input.clone();
        // Same effect applied
        return result;
    };
    
    if (!processedImage.empty()) {
        currentImage = processedImage.clone();
        rightSidebar->addLayer(QString("Brush Effect (%1)").arg(filter),
                              "brush", processedImage, operation);
        rightSidebar->updateHistogram(processedImage);
    }
    
    QMessageBox::information(this, "Brush Applied",
        QString("Applied %1 brush effect in center!\n\n"
                "Size: %2px\n"
                "Opacity: %3%\n"
                "Filter: %4")
        .arg(filter)
        .arg(size)
        .arg(opacity)
        .arg(filter));
    
    updateStatus(QString("Brush effect applied: %1").arg(filter), "success");
}

// ===== Metrics Display =====

void MainWindow::showImageMetrics() {
    if (!imageLoaded) {
        QMessageBox::information(this, "Info", "No image loaded!");
        return;
    }
    
    if (!recentlyProcessed || processedImage.empty()) {
        QMessageBox::warning(this, "Warning", 
            "No processed image to compare!\n\nApply a filter or transformation first.");
        return;
    }
    
    auto result = ImageMetrics::calculateMetrics(originalImage, processedImage);
    
    if (!result.isValid) {
        QMessageBox::critical(this, "Error", result.errorMessage);
        return;
    }
    
    QDialog *metricsDialog = new QDialog(this);
    metricsDialog->setWindowTitle("Image Quality Metrics");
    metricsDialog->setMinimumSize(500, 350);
    
    QVBoxLayout *layout = new QVBoxLayout(metricsDialog);
    
    QLabel *titleLabel = new QLabel("Quality Comparison: Original vs Processed");
    titleLabel->setStyleSheet("font-size: 14pt; font-weight: bold; color: #e879f9; padding: 15px;");
    layout->addWidget(titleLabel);
    
    QTextEdit *metricsText = new QTextEdit();
    metricsText->setReadOnly(true);
    metricsText->setStyleSheet(
        "background-color: rgba(45, 37, 71, 0.5); "
        "color: #f3e8ff; "
        "border: 2px solid rgba(91, 75, 115, 0.5); "
        "border-radius: 10px; "
        "padding: 20px; "
        "font-family: 'Consolas', monospace; "
        "font-size: 12pt;"
    );
    
    QString metricsInfo = ImageMetrics::formatMetrics(result);
    metricsInfo += "\n\n===================================\n";
    metricsInfo += "Interpretation:\n";
    metricsInfo += "===================================\n\n";
    metricsInfo += " MSE/RMSE: Lower is better (0 = identical)\n";
    metricsInfo += " SNR: Higher is better (signal vs noise)\n";
    metricsInfo += " PSNR: Higher is better\n";
    metricsInfo += "  - 30-50 dB: Good quality\n";
    metricsInfo += "  - 20-30 dB: Acceptable\n";
    metricsInfo += "  - <20 dB: Poor quality";
    
    metricsText->setText(metricsInfo);
    layout->addWidget(metricsText);
    
    QPushButton *closeBtn = new QPushButton("Close");
    closeBtn->setProperty("class", "accent");
    closeBtn->setMaximumWidth(150);
    connect(closeBtn, &QPushButton::clicked, metricsDialog, &QDialog::accept);
    
    QHBoxLayout *btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    btnLayout->addWidget(closeBtn);
    layout->addLayout(btnLayout);
    
    metricsDialog->exec();
}
